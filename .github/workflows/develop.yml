name: Application Pipeline

on:
  push:
    branches:
      - main

jobs:
  app-build:
    runs-on: ubuntu-latest
    outputs:
      BUCKET_ORIGIN_TEST_NAME: ${{ steps.config-pipe.outputs.BUCKET_ORIGIN_TEST_NAME }}
      AWS_ACCOUNT_TEST_ID: ${{ steps.config-pipe.outputs.AWS_ACCOUNT_TEST_ID }}
      USER_EMAIL: ${{ steps.config-pipe.outputs.USER_EMAIL }}
      NODE_VERSION: ${{ steps.config-pipe.outputs.NODE_VERSION }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Pipeline
        id: config-pipe
        run:
          echo "Reading the pipeline variables to start the configuration process"
          BUCKET_ORIGIN_TEST_NAME=$(grep BUCKET_ORIGIN_TEST_NAME .config | cut -d '=' -f 2)
          echo "BUCKET_ORIGIN_TEST_NAME=$BUCKET_ORIGIN_TEST_NAME" >> $GITHUB_ENV
          echo "AWS_ACCOUNT_TEST_ID=$AWS_ACCOUNT_TEST_ID" >> $GITHUB_ENV
          AWS_ACCOUNT_TEST_ID=$(grep AWS_ACCOUNT_TEST_ID .config | cut -d '=' -f 2)
          USER_EMAIL=$(grep USER_EMAIL .config | cut -d '=' -f 2)
          echo "USER_EMAIL=$USER_EMAIL" >> $GITHUB_ENV
          NODE_VERSION=$(grep NODE_VERSION .config | cut -d '=' -f 2)
          echo "NODE_VERSION=$NODE_VERSION" >> $GITHUB_ENV

      - name: Set up Node.js
        id: setup-node
        uses: actions/setup-node@v2
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        id: install-dependencies
        run: |
          echo "Installing Application dependencies..."
          if [ -f app/package.json ]; then
            cd app
            npm install
          else
            echo "package.json not found, skipping npm install"
          fi

      - name: Run tests
        id: run-tests
        run: |
          echo "Starting Application Tests"
        #   cd app/tests
        #   npm test

      - name: Build project
        id: build-project
        run: |
          echo "Starting the Build Process"
          if [ -f app/package.json ]; then
            cd app
            npm run build
          else
            echo "package.json not found, skipping npm build"
          fi

  aws-test-deployment:
    runs-on: ubuntu-latest
    needs: app-build
    steps: 
      - name: Install AWS CLI
        id: install-cli
        run: |
          sudo snap install aws-cli --classic
          aws --version

      # - name: Assume Role
      #   id: assume-role
      #   uses: aws-actions/configure-aws-credentials@v1
      #   with:
      #     role-to-assume: ${{ secrets.AWS_ROLE_ARN_DEV }}
      #     aws-region: us-east-1

      # - name: AWS Deployment
      #   id: aws-testdeploy
      #   env:
      #     AWS_ACCOUNT_ID: ${{ needs.app-build.outputs.AWS_ACCOUNT_TEST_ID }}
      #     BUCKET_NAME: ${{ needs.app-build.outputs.BUCKET_ORIGIN_TEST_NAME }}
      #   run: |
      #     echo "Provisioning the deployment on test evironment: $AWS_ACCOUNT_ID"
      #     cd app
      #     aws s3 sync . s3://$BUCKET_NAME

  post-deploy:
    runs-on: ubuntu-latest
    needs: aws-test-deployment
    steps:
      
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Archive artifact
        id: archive-artifact
        run: |
          if [ -d app/dist ]; then
            tar -czvf app/release-artifact.tar.gz -C app dist/
            echo "artifact_file=app/release-artifact.tar.gz" >> $GITHUB_ENV
          else
            echo "artifact_file=" >> $GITHUB_ENV
            echo "Directory app/dist does not exist, skipping artifact creation"
          fi

      - name: Upload artifact
        id: upload-artifact
        if: env.artifact_file != ''
        uses: actions/upload-artifact@v4
        with:
          name: release-artifact
          path: app/release-artifact.tar.gz

  release:
    runs-on: ubuntu-latest
    needs: post-deploy
    steps:
      
      - name: Checkout code
        uses: actions/checkout@v2
      
      - name: Getting older tags
        id: calculate-tag
        run: |
        
          latest_tag=$(git describe --tags `git rev-list --tags --max-count=1`)
          echo "Latest tag: $latest_tag"
          latest_version=${latest_tag#v}
          echo "Latest version: $latest_version"
          
          # Increment the version number
          IFS='.' read -r -a version_parts <<< "$latest_version"
          major=${version_parts[0]}
          minor=${version_parts[1]}
          patch=${version_parts[2]}
          new_version="$major.$minor.$((patch + 1))"
          new_tag="v$new_version"
          echo "New tag: $new_tag"
          
          # Set the new tag as an output
          echo "new_tag=$new_tag" >> $GITHUB_OUTPUT

      - name: Create new tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git tag ${{ steps.calculate-tag.outputs.new_tag }}
          git push origin ${{ steps.calculate-tag.outputs.new_tag }}

      - name: Create GitHub Release
        id: create-release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref }}
          release_name: Release ${{ github.ref }}
          draft: false
          prerelease: false

      - name: Upload Release Asset
        if: steps.create_release.outputs.upload_url != ''
        id: upload-release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: app/release-artifact.tar.gz
          asset_name: release-artifact.tar.gz
          asset_content_type: application/gzip

  production-aproval:
    runs-on: ubuntu-latest
    needs: release
    steps:
      - name: Request Approval
        id: request-approval
        uses: actions/github-script@v5
        with:
          script: |
            const { Octokit } = require("@octokit/core");
            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

            const { data: review } = await octokit.request('POST /repos/{owner}/{repo}/pulls', {
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'Approval Required',
              head: context.sha,
              base: 'main',
              body: 'Please approve this workflow run.',
              maintainer_can_modify: true
            });

            core.setOutput('review_url', review.html_url);

      - name: Approval Pending
        run: echo "Waiting for maintainer approval..."
        if: always()
        continue-on-error: true
        timeout-minutes: 60

  notification:
    runs-on: ubuntu-latest
    needs: [app-build, aws-test-deployment, post-deploy, release, production-aproval]
    if: failure()
    steps:
      - name: Failure Notification
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.example.com
          server_port: 587
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: 'GitHub Actions Workflow Failed'
          body: 'Houve um erro em sua pipeline! Acesse para conferir: '
          to: ${{ env.USER_EMAIL }}
          from: nttpipeline@example.com
    